# Research: Mobile Script Review Web Application

**Date**: 2026-01-17  
**Researcher**: Researcher Agent  
**Context**: Building a mobile-friendly web application for reviewing AI-generated DJ scripts with a Tinder-like swipe interface, allowing remote access and approval workflow management.

---

## Executive Summary

This research covers the design and implementation of a mobile-first Progressive Web App (PWA) for reviewing DJ scripts generated by the ESP32 AI Radio project. The app will enable remote script review via swipe gestures, with approval/rejection workflows, comment capabilities, and organized storage.

### Key Recommendations
1. **Backend**: Use **FastAPI** for modern Python API with auto-validation and excellent docs
2. **Frontend**: Vanilla JavaScript with **Tailwind CSS** for lightweight, responsive UI
3. **Swipe Library**: Use vanilla JS touch events or lightweight library like Hammer.js
4. **Storage**: JSON file-based storage with structured folder organization
5. **Security**: Simple token authentication with HTTPS, CORS restrictions
6. **Architecture**: Progressive Web App with offline capability via service workers

---

## Table of Contents
1. [Backend Framework Selection](#backend-framework-selection)
2. [Frontend Technologies](#frontend-technologies)
3. [Swipe Interface Implementation](#swipe-interface-implementation)
4. [Authentication & Security](#authentication--security)
5. [Data Storage & Organization](#data-storage--organization)
6. [UI/UX Design Patterns](#uiux-design-patterns)
7. [Progressive Web App Features](#progressive-web-app-features)
8. [Common Pitfalls & Mistakes](#common-pitfalls--mistakes)
9. [Implementation Recommendations](#implementation-recommendations)

---

## Backend Framework Selection

### Comparison: Flask vs FastAPI vs Django

For a **simple CRUD API** with **file-based JSON storage** and **lightweight requirements**:

| Feature | FastAPI ⭐ | Flask | Django |
|---------|-----------|-------|--------|
| **Learning Curve** | Moderate | Easy | Steep |
| **Data Validation** | Built-in (Pydantic) | Manual (need Marshmallow) | Built-in (ORM-focused) |
| **Performance** | Excellent (async) | Good (sync) | Good |
| **Auto-Generated Docs** | Yes (Swagger/OpenAPI) | No | No (DRF has it) |
| **Boilerplate** | Minimal | Minimal | Heavy |
| **Best For** | Modern APIs, type safety | Quick prototypes | Full-stack apps |
| **File Size** | Lightweight | Lightest | Heavy |

### Recommendation: **FastAPI**

**Why FastAPI wins for this project:**
- **Automatic validation** using Python type hints saves development time
- **Interactive API docs** (Swagger UI) makes testing and debugging easier
- **Async support** allows for future scalability (though not critical for file I/O)
- **Modern best practices** built-in from the start
- **Small learning curve** compared to the value it provides

**When Flask would be better:**
- If you want the absolute fastest prototype with minimal "extra" features
- If your team is already deeply familiar with Flask patterns

**Trade-offs:**
- FastAPI requires understanding of type hints and async patterns
- Slightly more setup than Flask's "hello world"
- Ecosystem is younger (but rapidly growing)

---

## Frontend Technologies

### CSS Framework: Tailwind CSS vs Bootstrap

| Criteria | Tailwind CSS ⭐ | Bootstrap |
|----------|----------------|-----------|
| **Approach** | Utility-first classes | Pre-built components |
| **File Size (optimized)** | Very small (with PurgeCSS) | Larger |
| **Customization** | Maximum flexibility | Theme variables only |
| **Learning Curve** | Steeper initially | Beginner-friendly |
| **Mobile-First** | Excellent (granular control) | Good (grid-based) |
| **JavaScript Required** | Minimal/None | Yes (for components) |
| **Design Uniqueness** | Complete control | Bootstrap "look" |

### Recommendation: **Tailwind CSS**

**Why Tailwind for this project:**
1. **Lightweight**: With PurgeCSS, ships only the CSS you use
2. **No JS overhead**: Pure CSS solution (we'll add our own minimal JS)
3. **Mobile-first**: Responsive breakpoints (`sm:`, `md:`, `lg:`) are intuitive
4. **Unique design**: Won't look like every Bootstrap site
5. **Perfect for cards**: Easy to style swipeable card interfaces

**Alternative if speed is priority:**
- Bootstrap for rapid prototyping with pre-built card components
- But you'll need to override styles for Tinder-like appearance

---

## Swipe Interface Implementation

### Available Options

#### 1. **Vanilla JavaScript (Recommended for Learning)**
```javascript
// Touch event handling
element.addEventListener('touchstart', handleTouchStart);
element.addEventListener('touchmove', handleTouchMove);
element.addEventListener('touchend', handleTouchEnd);
```

**Pros:**
- Zero dependencies
- Full control over physics and animations
- Lightweight
- Educational

**Cons:**
- Must implement all gesture logic yourself
- More code to write and maintain

#### 2. **Hammer.js (Recommended for Production)**
```javascript
const hammer = new Hammer(element);
hammer.on('swipeleft swiperight', handleSwipe);
```

**Pros:**
- Battle-tested gesture recognition
- Handles edge cases (diagonal swipes, multitouch)
- Cross-device compatibility
- Small footprint (~7KB gzipped)

**Cons:**
- External dependency
- May be overkill for simple left/right swipes

#### 3. **Framework-Specific Solutions**
- **Vue**: Tallman Swiper (if using Vue.js)
- **React**: react-tinder-card (if using React)

**Not recommended for this project** - adds framework overhead

### Recommendation: **Start with Vanilla JS, upgrade to Hammer.js if needed**

**Implementation Pattern:**
```javascript
let startX, currentX, isDragging = false;

card.addEventListener('touchstart', (e) => {
    startX = e.touches[0].clientX;
    isDragging = true;
});

card.addEventListener('touchmove', (e) => {
    if (!isDragging) return;
    currentX = e.touches[0].clientX;
    const diff = currentX - startX;
    // Apply transform to card
    card.style.transform = `translateX(${diff}px) rotate(${diff/10}deg)`;
});

card.addEventListener('touchend', () => {
    const diff = currentX - startX;
    if (Math.abs(diff) > 100) {
        // Swipe threshold met
        if (diff > 0) handleApprove();
        else handleReject();
    } else {
        // Snap back
        card.style.transform = '';
    }
    isDragging = false;
});
```

**Key Features to Implement:**
- Visual feedback during swipe (rotation, opacity)
- Snap-back animation if threshold not met
- Smooth card removal animation on approve/reject
- Next card reveal from stack
- Keyboard support for accessibility (arrow keys)

---

## Authentication & Security

### Security Requirements
1. **Remote Access**: App must be accessible outside home network
2. **Simple Auth**: No complex user management needed (single user or small team)
3. **File Uploads**: Scripts are read-only, but comments/metadata are written

### Recommended Approach: **Token-Based Authentication**

#### Implementation Pattern
```python
from functools import wraps
from flask import request, jsonify
import os

API_TOKEN = os.environ.get("SCRIPT_REVIEW_TOKEN")

def token_required(f):
    @wraps(f)
    def decorator(*args, **kwargs):
        token = request.headers.get("Authorization")
        if token != f"Bearer {API_TOKEN}":
            return jsonify({"error": "Unauthorized"}), 401
        return f(*args, **kwargs)
    return decorator

@app.route('/api/scripts', methods=['GET'])
@token_required
def get_scripts():
    # Your logic here
    pass
```

#### Security Best Practices

**1. HTTPS Everywhere**
- Use Let's Encrypt for free SSL certificates
- Enforce HTTPS with HSTS headers
- Service workers require HTTPS (except localhost)

**2. CORS Configuration**
```python
from flask_cors import CORS

# Restrict to your domain only
CORS(app, resources={
    r"/api/*": {
        "origins": ["https://yourdomain.com"],
        "methods": ["GET", "POST"],
        "allow_headers": ["Content-Type", "Authorization"]
    }
})
```

**3. Token Management**
- Store token in environment variables (never in code)
- Use secure, random token: `openssl rand -hex 32`
- Rotate tokens periodically
- Consider token expiry for production

**4. Input Validation**
```python
from pydantic import BaseModel, validator

class ScriptReview(BaseModel):
    script_id: str
    status: str  # "approved" or "rejected"
    reason: str | None = None
    
    @validator('status')
    def validate_status(cls, v):
        if v not in ['approved', 'rejected']:
            raise ValueError('Invalid status')
        return v
```

**5. Rate Limiting**
- Implement basic rate limiting to prevent abuse
- Use Flask-Limiter or similar

### Common Security Pitfalls

❌ **AVOID:**
- Storing tokens in localStorage (vulnerable to XSS)
- Using `CORS origins="*"` in production
- Hardcoding credentials
- Accepting file uploads without validation
- Serving user-uploaded content from same domain

✅ **DO:**
- Use httpOnly cookies if possible (for web-only access)
- Validate all inputs server-side
- Log authentication failures
- Implement request size limits
- Use Content Security Policy headers

---

## Data Storage & Organization

### Folder Structure for Script Review Workflow

```
output/
├── scripts/
│   ├── pending_review/          # Scripts awaiting review
│   │   ├── julie/
│   │   ├── mr_new_vegas/
│   │   └── travis_miles_nervous/
│   │
│   ├── approved/                # Passed scripts
│   │   ├── julie/
│   │   ├── mr_new_vegas/
│   │   └── travis_miles_nervous/
│   │
│   ├── rejected/                # Failed scripts with reasons
│   │   ├── julie/
│   │   ├── mr_new_vegas/
│   │   └── travis_miles_nervous/
│   │
│   └── metadata/                # Review metadata & comments
│       ├── approved.json
│       ├── rejected.json
│       └── rejection_reasons.json  # Pre-defined reasons
```

### File Naming Convention
```
YYYY-MM-DD_HHMMSS_DJName_ContentType_Status.txt

Examples:
2026-01-17_143022_Julie_News_Pending.txt
2026-01-17_143022_Julie_News_Approved.txt
2026-01-17_143022_Julie_News_Rejected.txt
```

### Metadata Storage (JSON)

**rejection_reasons.json** - Pre-defined reasons
```json
{
  "reasons": [
    {
      "id": "tone_mismatch",
      "label": "Tone doesn't match DJ personality",
      "category": "personality"
    },
    {
      "id": "factual_error",
      "label": "Contains factual errors",
      "category": "accuracy"
    },
    {
      "id": "temporal_violation",
      "label": "References wrong time period",
      "category": "lore"
    },
    {
      "id": "too_generic",
      "label": "Too generic/boring",
      "category": "quality"
    },
    {
      "id": "inappropriate",
      "label": "Inappropriate content",
      "category": "content"
    },
    {
      "id": "other",
      "label": "Other (please specify)",
      "category": "other"
    }
  ]
}
```

**approved.json** - Approved scripts log
```json
{
  "reviews": [
    {
      "script_id": "2026-01-17_143022_Julie_News",
      "dj": "Julie",
      "content_type": "News",
      "reviewed_at": "2026-01-17T14:35:00Z",
      "reviewer": "user",
      "notes": ""
    }
  ]
}
```

**rejected.json** - Rejected scripts with reasons
```json
{
  "reviews": [
    {
      "script_id": "2026-01-17_143022_Julie_News",
      "dj": "Julie",
      "content_type": "News",
      "reviewed_at": "2026-01-17T14:35:00Z",
      "reviewer": "user",
      "reason_id": "tone_mismatch",
      "custom_comment": "Too formal, doesn't sound like Julie"
    }
  ]
}
```

### Best Practices for File Organization

1. **Atomic Moves**: Use `shutil.move()` for atomic file operations
2. **Backup Before Move**: Keep original in pending until move confirmed
3. **Metadata First**: Write metadata before moving file
4. **Transaction Log**: Log all review actions for audit trail
5. **Cleanup**: Periodically archive old reviewed scripts
6. **Version Control**: Consider git for metadata files

---

## UI/UX Design Patterns

### Card-Based Review Interface

#### Layout Structure
```
┌─────────────────────────┐
│   Logo / Title          │
│   "Script Review"       │
├─────────────────────────┤
│                         │
│   ┌─────────────────┐   │
│   │                 │   │ 
│   │   DJ: Julie     │   │
│   │   Type: News    │   │
│   │   Date: 1/17    │   │
│   │                 │   │
│   │   [Script Text] │   │
│   │   ...           │   │
│   │   ...           │   │
│   │                 │   │
│   └─────────────────┘   │
│                         │
│   ← Reject   Approve →  │
│                         │
├─────────────────────────┤
│   Filters: [All DJs ▼]  │
│   Progress: 5/23        │
└─────────────────────────┘
```

#### Visual Hierarchy Best Practices

**Card Content Priority:**
1. **DJ Name** (largest, most prominent)
2. **Content Type** (News/Weather/Gossip)
3. **Timestamp/Date**
4. **Script Text** (scrollable if long)
5. **Metadata** (word count, source, etc.)

**Color Coding:**
- Julie: Warm tones (orange/amber)
- Mr. New Vegas: Blue/teal
- Travis: Green/yellow
- Consistent with DJ brand identity

**Typography:**
- Headers: 18-24px, bold
- Body text: 16px minimum (mobile readability)
- Line height: 1.5-1.6 for comfortable reading
- Max line length: 65-75 characters

#### Mobile Touch Target Guidelines

- **Minimum touch target**: 48x48 pixels
- **Spacing between targets**: 8px minimum
- **Swipe threshold**: 100-150px horizontal drag
- **Swipe animation**: 300ms ease-out

#### Interaction Patterns

**Swipe Gestures:**
- Swipe right → Approve (green visual feedback)
- Swipe left → Reject (red visual feedback, show comment modal)
- Tap card → Expand to full-screen reading mode
- Double-tap → No action (prevent accidents)

**Alternative Controls (Accessibility):**
- ✓ Button (approve)
- ✗ Button (reject)
- Keyboard: Arrow right = approve, Arrow left = reject
- Screen reader: Announce card content and available actions

**Rejection Flow:**
```
1. User swipes left
2. Card slides off with red tint
3. Modal appears: "Why reject?"
4. Dropdown shows pre-defined reasons
5. If "Other" selected → Text input appears
6. User types custom reason (optional)
7. Submit button → Save and show next card
8. Cancel button → Undo rejection, card returns
```

### Common UX Mistakes to Avoid

❌ **Don't:**
- Use small touch targets (<44px)
- Hide critical actions in menus
- Auto-advance without confirmation
- Use complex navigation
- Ignore landscape orientation
- Assume hover states work on mobile
- Make text too small to read
- Require precise interactions

✅ **Do:**
- Provide visual feedback for all touches
- Use familiar mobile patterns
- Support both portrait and landscape
- Enable undo actions
- Show progress indicators
- Use large, clear buttons
- Implement haptic feedback (if available)
- Test on real devices, not just emulators

---

## Progressive Web App Features

### Why PWA?

**Benefits for Script Review:**
1. **Install to home screen** - Feels like native app
2. **Offline capability** - Review scripts without connection
3. **Background sync** - Upload reviews when connection restored
4. **Fast loading** - Cached assets load instantly
5. **No app store** - Direct web access

### PWA Implementation Checklist

#### 1. Web App Manifest (`manifest.json`)
```json
{
  "name": "DJ Script Review",
  "short_name": "Script Review",
  "description": "Review AI-generated DJ scripts",
  "start_url": "/",
  "display": "standalone",
  "background_color": "#1a1a1a",
  "theme_color": "#3b82f6",
  "orientation": "portrait",
  "icons": [
    {
      "src": "/icons/icon-192.png",
      "sizes": "192x192",
      "type": "image/png"
    },
    {
      "src": "/icons/icon-512.png",
      "sizes": "512x512",
      "type": "image/png"
    }
  ]
}
```

#### 2. Service Worker (`service-worker.js`)
```javascript
const CACHE_NAME = 'script-review-v1';
const urlsToCache = [
  '/',
  '/index.html',
  '/styles.css',
  '/app.js',
  '/manifest.json'
];

// Install event: Cache app shell
self.addEventListener('install', (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME)
      .then(cache => cache.addAll(urlsToCache))
  );
});

// Fetch event: Serve from cache, fallback to network
self.addEventListener('fetch', (event) => {
  event.respondWith(
    caches.match(event.request)
      .then(response => response || fetch(event.request))
  );
});

// Activate event: Clean up old caches
self.addEventListener('activate', (event) => {
  event.waitUntil(
    caches.keys().then(cacheNames =>
      Promise.all(
        cacheNames
          .filter(name => name !== CACHE_NAME)
          .map(name => caches.delete(name))
      )
    )
  );
});
```

#### 3. Service Worker Registration
```javascript
// In your main app.js
if ('serviceWorker' in navigator) {
  window.addEventListener('load', () => {
    navigator.serviceWorker.register('/service-worker.js')
      .then(registration => {
        console.log('SW registered:', registration);
      })
      .catch(error => {
        console.log('SW registration failed:', error);
      });
  });
}
```

### Offline Strategy

**Cache-First for Static Assets:**
- HTML, CSS, JavaScript
- Icons, fonts
- UI framework code

**Network-First for Dynamic Data:**
- Script list API
- Review submission
- Fallback to cached data if offline

**Background Sync:**
- Queue review decisions when offline
- Sync when connection restored
- Show offline indicator in UI

---

## Common Pitfalls & Mistakes

### Mobile Web App Development Pitfalls

#### 1. **Not Using Mobile-First Design**
❌ **Problem**: Designing for desktop first leads to compromised mobile UX
✅ **Solution**: Start with smallest screen, progressively enhance for larger

#### 2. **Ignoring Touch Targets**
❌ **Problem**: Buttons too small or too close together
✅ **Solution**: 48x48px minimum, generous spacing, visual feedback

#### 3. **Poor Performance on Mobile Networks**
❌ **Problem**: Large bundles, unoptimized images slow load times
✅ **Solution**: 
- Compress images (WebP format)
- Minify CSS/JS
- Lazy load content
- Use CDN for static assets
- Enable gzip compression

#### 4. **Only Testing in Browser**
❌ **Problem**: Emulators miss real device issues
✅ **Solution**: Test on actual phones (iOS and Android)

#### 5. **Complex Navigation**
❌ **Problem**: Multi-level menus confuse users
✅ **Solution**: Flat navigation, bottom nav bar, clear CTAs

#### 6. **Neglecting Accessibility**
❌ **Problem**: App unusable with screen readers or for users with disabilities
✅ **Solution**:
- ARIA labels
- Keyboard navigation
- High contrast mode
- Focus indicators
- Alternative to gesture-only controls

#### 7. **Inadequate Error Handling**
❌ **Problem**: No feedback after actions, silent failures
✅ **Solution**: Toast notifications, error messages, loading states

#### 8. **Not Handling Network Failures**
❌ **Problem**: App breaks when offline or on slow connection
✅ **Solution**: Offline mode, retry logic, queue actions

### Backend API Pitfalls

#### 1. **Not Validating Input**
❌ **Problem**: Accepting any data leads to bugs and security issues
✅ **Solution**: Use Pydantic models, validate all inputs

#### 2. **Exposing Internal Paths**
❌ **Problem**: Returning full file system paths in API responses
✅ **Solution**: Return relative IDs, map to paths server-side

#### 3. **No Rate Limiting**
❌ **Problem**: API can be abused or overwhelmed
✅ **Solution**: Implement per-IP rate limits

#### 4. **Synchronous File Operations**
❌ **Problem**: Blocking on large file reads/writes
✅ **Solution**: Use async file operations or background tasks

#### 5. **No Logging**
❌ **Problem**: Can't debug issues or track usage
✅ **Solution**: Log all review actions, errors, auth failures

### File Storage Pitfalls

#### 1. **Race Conditions**
❌ **Problem**: Multiple processes modifying same file
✅ **Solution**: Use file locking, atomic operations, transaction log

#### 2. **No Backup Strategy**
❌ **Problem**: Data loss on file corruption
✅ **Solution**: Regular backups, version control for metadata

#### 3. **Inconsistent Naming**
❌ **Problem**: Scripts hard to find or organize
✅ **Solution**: Strict naming convention, validation on file creation

#### 4. **No Cleanup Policy**
❌ **Problem**: Disk fills up with old reviewed scripts
✅ **Solution**: Archive policy, move old files to cold storage

---

## Implementation Recommendations

### Development Phases

#### Phase 1: Core Backend API (Week 1)
- [ ] Set up FastAPI project structure
- [ ] Implement script listing endpoint (GET /api/scripts)
- [ ] Implement review submission endpoint (POST /api/review)
- [ ] File organization system (pending → approved/rejected)
- [ ] JSON metadata storage
- [ ] Token authentication
- [ ] CORS configuration
- [ ] Basic error handling

#### Phase 2: Frontend UI (Week 2)
- [ ] HTML structure with semantic markup
- [ ] Tailwind CSS styling
- [ ] Card component layout
- [ ] Vanilla JS swipe gesture detection
- [ ] API integration (fetch calls)
- [ ] Loading states and error handling
- [ ] Responsive design (mobile + desktop)

#### Phase 3: Advanced Features (Week 3)
- [ ] Rejection reason dropdown with autocomplete
- [ ] Custom comment input
- [ ] DJ filter (single DJ vs all DJs shuffled)
- [ ] Progress tracking
- [ ] Undo last action
- [ ] Keyboard shortcuts
- [ ] Animation polish

#### Phase 4: PWA & Polish (Week 4)
- [ ] Web app manifest
- [ ] Service worker implementation
- [ ] Offline capability
- [ ] Install prompt
- [ ] Icons and splash screens
- [ ] Performance optimization
- [ ] Accessibility audit
- [ ] Cross-device testing

### Technology Stack Summary

**Backend:**
- FastAPI (Python 3.10+)
- Pydantic for validation
- Python standard library (json, shutil, pathlib)
- Uvicorn (ASGI server)

**Frontend:**
- HTML5
- Tailwind CSS (via CDN or npm)
- Vanilla JavaScript (ES6+)
- Optional: Hammer.js for gestures

**Deployment:**
- HTTPS (Let's Encrypt)
- Reverse proxy (Nginx)
- Process manager (systemd or PM2)
- Optional: Docker for containerization

**Development Tools:**
- VS Code with Python/JS extensions
- Browser DevTools
- Lighthouse for PWA audit
- Real device testing (iOS Safari, Chrome Android)

### File Structure

```
script-review-app/
├── backend/
│   ├── main.py                 # FastAPI app
│   ├── models.py               # Pydantic models
│   ├── auth.py                 # Authentication
│   ├── storage.py              # File operations
│   ├── config.py               # Settings
│   └── requirements.txt
│
├── frontend/
│   ├── index.html              # Main page
│   ├── styles.css              # Tailwind build output
│   ├── app.js                  # Application logic
│   ├── swipe.js                # Gesture handling
│   ├── api.js                  # API client
│   ├── manifest.json           # PWA manifest
│   ├── service-worker.js       # Service worker
│   └── icons/                  # App icons
│
├── data/
│   └── rejection_reasons.json  # Pre-defined reasons
│
├── output/
│   └── scripts/                # Script files (from main project)
│       ├── pending_review/
│       ├── approved/
│       ├── rejected/
│       └── metadata/
│
├── .env                        # Environment variables
├── .gitignore
└── README.md
```

### Environment Variables

```bash
# .env file
SCRIPT_REVIEW_TOKEN=your-secret-token-here
SCRIPTS_BASE_PATH=/path/to/esp32-project/output/scripts
ALLOWED_ORIGINS=https://yourdomain.com
LOG_LEVEL=INFO
```

### API Endpoints Design

```
GET  /api/scripts?dj={dj_name}&status=pending
     Returns list of scripts to review
     
POST /api/review
     Body: {
       "script_id": "2026-01-17_143022_Julie_News",
       "status": "approved|rejected",
       "reason_id": "tone_mismatch",  // if rejected
       "custom_comment": "..."        // if rejected with "other"
     }
     
GET  /api/reasons
     Returns list of pre-defined rejection reasons
     
POST /api/reasons
     Body: {"label": "New reason", "category": "quality"}
     Adds new rejection reason to list
     
GET  /api/stats
     Returns review statistics (approved count, rejected count, etc.)
```

### Security Checklist

- [ ] HTTPS enforced
- [ ] CORS restricted to specific domain
- [ ] Token in environment variable
- [ ] Input validation on all endpoints
- [ ] File path validation (prevent directory traversal)
- [ ] Rate limiting implemented
- [ ] Security headers configured
- [ ] Sensitive data not logged
- [ ] Regular dependency updates

### Performance Targets

- **First Contentful Paint**: < 1.5s
- **Time to Interactive**: < 3s
- **Lighthouse Score**: > 90
- **Bundle Size**: < 100KB (gzipped)
- **API Response Time**: < 200ms

---

## References & Further Reading

### Backend Frameworks
- [FastAPI Official Documentation](https://fastapi.tiangolo.com/)
- [Pydantic Validation](https://docs.pydantic.dev/)
- [Flask vs FastAPI vs Django Comparison](https://developersvoice.com/blog/python/fastapi_django_flask_architecture_guide/)

### Frontend & UI
- [Tailwind CSS Documentation](https://tailwindcss.com/docs)
- [Hammer.js Touch Gestures](http://hammerjs.github.io/)
- [Card UI Best Practices - Mobbin](https://mobbin.com/glossary/card)
- [Mobile UX Design Guide](https://userpilot.com/blog/mobile-ux-design/)

### PWA & Service Workers
- [MDN: Service Workers](https://developer.mozilla.org/en-US/docs/Web/API/Service_Worker_API)
- [Google PWA Checklist](https://web.dev/pwa-checklist/)
- [PWA Security Best Practices](https://appinstitute.com/9-pwa-security-practices-for-2025/)

### Security
- [OWASP Mobile Security](https://mas.owasp.org/MASTG/0x04e-Testing-Authentication-and-Session-Management/)
- [Flask Security Best Practices](https://hub.corgea.com/articles/flask-security-best-practices-2025)
- [API Authentication Methods](https://strapi.io/blog/6-Authentication-Methods-for-Secure-Web-Applications)

### UX Patterns
- [Form UX Best Practices](https://www.zuko.io/blog/form-ux-design-tips-best-practice-examples)
- [Autocomplete Design Patterns](https://baymard.com/blog/autocomplete-design)
- [Mobile-First Design Mistakes](https://globetechsoft.com/blog/mobile-mayhem-mistakes-to-avoid-when-designing-responsive-websites/)

---

## Conclusion

Building a mobile script review app requires balancing simplicity with functionality. The recommended stack (FastAPI + Vanilla JS + Tailwind + PWA) provides a modern, performant solution while keeping the codebase manageable.

**Critical Success Factors:**
1. **Mobile-First**: Design for thumb-friendly interaction from day one
2. **Simplicity**: Swipe right/left is intuitive, don't over-complicate
3. **Feedback**: Clear visual/haptic feedback for every action
4. **Offline Support**: PWA enables review anywhere, anytime
5. **Security**: Token auth + HTTPS + CORS keeps data safe
6. **Testing**: Test on real devices throughout development

**Next Steps:**
1. Set up development environment
2. Create backend API skeleton
3. Build minimal frontend with swipe prototype
4. Test on actual mobile device
5. Iterate based on real usage
6. Add PWA features
7. Deploy with HTTPS

**Estimated Timeline**: 3-4 weeks for full implementation with polish

---

**Document Version**: 1.0  
**Last Updated**: 2026-01-17
